package service

import (
	"context"

	"github.com/NarthurN/habbr/internal/model"
	"github.com/google/uuid"
)

//go:generate mockery --name PostService --output ./mocks --filename mock_post_service.go

// PostService определяет интерфейс сервиса для работы с постами.
//
// Этот интерфейс инкапсулирует всю бизнес-логику, связанную с управлением постами,
// включая их создание, чтение, обновление и удаление (CRUD операции).
// Сервис также обеспечивает валидацию данных, проверку прав доступа и пагинацию.
//
// Реализация должна:
// - Валидировать все входные данные перед обработкой
// - Проверять права доступа (автор может изменять только свои посты)
// - Обеспечивать транзакционность операций
// - Логировать важные операции
// - Возвращать доменные ошибки с понятными сообщениями
//
// Пример использования:
//   postService := post.NewService(repositories, logger)
//   post, err := postService.CreatePost(ctx, postInput)
//   if err != nil {
//       return fmt.Errorf("failed to create post: %w", err)
//   }
type PostService interface {
	// CreatePost создает новый пост в системе.
	//
	// Метод выполняет полную валидацию входных данных, создает новый пост
	// с уникальным ID и временными метками, затем сохраняет его в репозитории.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции и передачи метаданных
	//   - input: валидированные данные для создания поста
	//
	// Возвращает:
	//   - *model.Post: созданный пост с заполненными системными полями
	//   - error: ошибка валидации, доступа к данным или другая системная ошибка
	//
	// Возможные ошибки:
	//   - model.ValidationError: некорректные входные данные
	//   - model.InternalError: проблемы с базой данных или системные ошибки
	//
	// Пример использования:
	//   input := model.PostInput{
	//       Title: "Новый пост",
	//       Content: "Содержимое поста",
	//       AuthorID: userID,
	//       CommentsEnabled: true,
	//   }
	//   post, err := service.CreatePost(ctx, input)
	CreatePost(ctx context.Context, input model.PostInput) (*model.Post, error)

	// GetPost получает пост по его уникальному идентификатору.
	//
	// Метод возвращает полную информацию о посте, включая все его поля.
	// Проверяет существование поста в системе.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор поста в формате UUID
	//
	// Возвращает:
	//   - *model.Post: найденный пост со всеми данными
	//   - error: ошибка если пост не найден или произошла системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: пост с указанным ID не существует
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   post, err := service.GetPost(ctx, postID)
	//   if err != nil {
	//       if errors.Is(err, model.ErrNotFound) {
	//           return nil, fmt.Errorf("пост не найден")
	//       }
	//       return nil, err
	//   }
	GetPost(ctx context.Context, id uuid.UUID) (*model.Post, error)

	// ListPosts возвращает список постов с поддержкой фильтрации и пагинации.
	//
	// Метод обеспечивает эффективную выборку постов с использованием cursor-based
	// пагинации, что гарантирует стабильные результаты даже при добавлении новых постов.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - filter: критерии фильтрации (автор, настройки комментариев)
	//   - pagination: параметры пагинации (количество, cursors)
	//
	// Возвращает:
	//   - *model.PostConnection: объект с постами, cursors и информацией о пагинации
	//   - error: ошибка выполнения запроса
	//
	// Возможные ошибки:
	//   - model.ValidationError: некорректные параметры пагинации
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   filter := model.PostFilter{AuthorID: &userID}
	//   pagination := model.PaginationInput{First: &10}
	//   connection, err := service.ListPosts(ctx, filter, pagination)
	//   for _, edge := range connection.Edges {
	//       fmt.Printf("Post: %s\n", edge.Node.Title)
	//   }
	ListPosts(ctx context.Context, filter model.PostFilter, pagination model.PaginationInput) (*model.PostConnection, error)

	// UpdatePost обновляет существующий пост новыми данными.
	//
	// Метод проверяет права доступа (только автор может изменять пост),
	// валидирует новые данные и применяет изменения к существующему посту.
	// Обновляет временную метку последнего изменения.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор обновляемого поста
	//   - input: новые данные для обновления (только указанные поля)
	//   - authorID: идентификатор пользователя, выполняющего обновление
	//
	// Возвращает:
	//   - *model.Post: обновленный пост с новыми данными
	//   - error: ошибка валидации, прав доступа или системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: пост с указанным ID не существует
	//   - model.ForbiddenError: пользователь не является автором поста
	//   - model.ValidationError: некорректные данные для обновления
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   newTitle := "Обновленный заголовок"
	//   update := model.PostUpdateInput{Title: &newTitle}
	//   post, err := service.UpdatePost(ctx, postID, update, userID)
	UpdatePost(ctx context.Context, id uuid.UUID, input model.PostUpdateInput, authorID uuid.UUID) (*model.Post, error)

	// DeletePost удаляет пост и все связанные с ним комментарии.
	//
	// Метод проверяет права доступа (только автор может удалить пост),
	// затем выполняет каскадное удаление поста и всех его комментариев.
	// Операция необратима и выполняется в транзакции.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор удаляемого поста
	//   - authorID: идентификатор пользователя, выполняющего удаление
	//
	// Возвращает:
	//   - error: ошибка прав доступа, отсутствия поста или системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: пост с указанным ID не существует
	//   - model.ForbiddenError: пользователь не является автором поста
	//   - model.InternalError: проблемы с базой данных или транзакцией
	//
	// Пример использования:
	//   err := service.DeletePost(ctx, postID, userID)
	//   if err != nil {
	//       if errors.Is(err, model.ErrForbidden) {
	//           return fmt.Errorf("нет прав для удаления поста")
	//       }
	//       return err
	//   }
	DeletePost(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error

	// ToggleComments переключает возможность комментирования поста.
	//
	// Метод позволяет автору поста включать или отключать возможность
	// добавления новых комментариев. Существующие комментарии сохраняются.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - postID: уникальный идентификатор поста
	//   - authorID: идентификатор автора поста
	//   - enabled: новое состояние (true - разрешить, false - запретить)
	//
	// Возвращает:
	//   - *model.Post: обновленный пост с новыми настройками
	//   - error: ошибка прав доступа, отсутствия поста или системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: пост с указанным ID не существует
	//   - model.ForbiddenError: пользователь не является автором поста
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   // Отключить комментарии
	//   post, err := service.ToggleComments(ctx, postID, userID, false)
	ToggleComments(ctx context.Context, postID uuid.UUID, authorID uuid.UUID, enabled bool) (*model.Post, error)
}

//go:generate mockery --name CommentService --output ./mocks --filename mock_comment_service.go

// CommentService определяет интерфейс сервиса для работы с комментариями.
//
// Этот интерфейс инкапсулирует бизнес-логику управления иерархическими комментариями,
// включая создание, чтение, обновление и удаление. Сервис также обеспечивает
// построение древовидной структуры и отправку real-time уведомлений.
//
// Реализация должна:
// - Валидировать входные данные и проверять бизнес-правила
// - Управлять иерархией комментариев и вычислять глубину
// - Проверять права доступа на операции
// - Отправлять уведомления подписчикам через WebSocket
// - Обеспечивать целостность данных при удалении
//
// Пример использования:
//   commentService := comment.NewService(repositories, logger, subscriptionService)
//   comment, err := commentService.CreateComment(ctx, commentInput)
type CommentService interface {
	// CreateComment создает новый комментарий к посту или ответ на существующий комментарий.
	//
	// Метод выполняет следующие проверки и действия:
	// - Проверяет существование поста и разрешение комментирования
	// - Если указан ParentID, проверяет существование родительского комментария
	// - Вычисляет правильную глубину вложенности
	// - Создает комментарий с уникальным ID
	// - Отправляет real-time уведомление подписчикам
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - input: валидированные данные для создания комментария
	//
	// Возвращает:
	//   - *model.Comment: созданный комментарий с заполненными системными полями
	//   - error: ошибка валидации, бизнес-правил или системная ошибка
	//
	// Возможные ошибки:
	//   - model.ValidationError: некорректные входные данные
	//   - model.NotFoundError: пост или родительский комментарий не найден
	//   - model.ForbiddenError: комментарии к посту отключены
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   // Корневой комментарий
	//   input := model.CommentInput{
	//       PostID: postID,
	//       Content: "Мой комментарий",
	//       AuthorID: userID,
	//   }
	//   comment, err := service.CreateComment(ctx, input)
	CreateComment(ctx context.Context, input model.CommentInput) (*model.Comment, error)

	// GetComment получает комментарий по его уникальному идентификатору.
	//
	// Метод возвращает полную информацию о комментарии, включая все поля.
	// Не загружает дочерние комментарии (для этого используйте ListComments).
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор комментария
	//
	// Возвращает:
	//   - *model.Comment: найденный комментарий без дочерних элементов
	//   - error: ошибка если комментарий не найден
	//
	// Возможные ошибки:
	//   - model.NotFoundError: комментарий с указанным ID не существует
	//   - model.InternalError: проблемы с базой данных
	GetComment(ctx context.Context, id uuid.UUID) (*model.Comment, error)

	// ListComments возвращает список комментариев с поддержкой фильтрации и пагинации.
	//
	// Метод позволяет получать комментарии по различным критериям:
	// - Все комментарии к определенному посту
	// - Только корневые комментарии (ParentID = nil)
	// - Дочерние комментарии определенного родителя
	// - Комментарии определенного автора
	// - С ограничением по глубине вложенности
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - filter: критерии фильтрации комментариев
	//   - pagination: параметры пагинации
	//
	// Возвращает:
	//   - *model.CommentConnection: объект с комментариями и информацией о пагинации
	//   - error: ошибка выполнения запроса
	//
	// Пример использования:
	//   // Получить корневые комментарии к посту
	//   filter := model.CommentFilter{PostID: &postID, ParentID: nil}
	//   pagination := model.PaginationInput{First: &20}
	//   connection, err := service.ListComments(ctx, filter, pagination)
	ListComments(ctx context.Context, filter model.CommentFilter, pagination model.PaginationInput) (*model.CommentConnection, error)

	// UpdateComment обновляет содержимое существующего комментария.
	//
	// Метод проверяет права доступа (только автор может изменять комментарий),
	// валидирует новые данные и применяет изменения. Отправляет уведомление
	// подписчикам о обновлении комментария.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор обновляемого комментария
	//   - input: новые данные для обновления
	//   - authorID: идентификатор пользователя, выполняющего обновление
	//
	// Возвращает:
	//   - *model.Comment: обновленный комментарий
	//   - error: ошибка валидации, прав доступа или системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: комментарий не найден
	//   - model.ForbiddenError: пользователь не является автором
	//   - model.ValidationError: некорректные данные
	UpdateComment(ctx context.Context, id uuid.UUID, input model.CommentUpdateInput, authorID uuid.UUID) (*model.Comment, error)

	// DeleteComment удаляет комментарий и все его дочерние комментарии.
	//
	// Метод выполняет каскадное удаление комментария и всех его ответов.
	// Проверяет права доступа и отправляет уведомления подписчикам.
	// Операция необратима и выполняется в транзакции.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - id: уникальный идентификатор удаляемого комментария
	//   - authorID: идентификатор пользователя, выполняющего удаление
	//
	// Возвращает:
	//   - error: ошибка прав доступа или системная ошибка
	//
	// Возможные ошибки:
	//   - model.NotFoundError: комментарий не найден
	//   - model.ForbiddenError: пользователь не является автором
	//   - model.InternalError: проблемы с базой данных
	DeleteComment(ctx context.Context, id uuid.UUID, authorID uuid.UUID) error

	// GetCommentsTree возвращает полное дерево комментариев для поста.
	//
	// Метод загружает все комментарии к указанному посту и строит из них
	// иерархическую структуру с заполненными полями Children. Корневые
	// комментарии возвращаются в порядке создания.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - postID: уникальный идентификатор поста
	//
	// Возвращает:
	//   - []*model.Comment: список корневых комментариев с построенным деревом
	//   - error: ошибка загрузки данных
	//
	// Возможные ошибки:
	//   - model.NotFoundError: пост не найден
	//   - model.InternalError: проблемы с базой данных
	//
	// Пример использования:
	//   tree, err := service.GetCommentsTree(ctx, postID)
	//   for _, rootComment := range tree {
	//       printCommentTree(rootComment, 0) // рекурсивный вывод
	//   }
	GetCommentsTree(ctx context.Context, postID uuid.UUID) ([]*model.Comment, error)

	// GetCommentStats возвращает статистику комментариев для поста.
	//
	// Метод подсчитывает общее количество комментариев к посту,
	// включая все уровни вложенности. Полезно для отображения счетчиков.
	//
	// Параметры:
	//   - ctx: контекст запроса для отмены операции
	//   - postID: уникальный идентификатор поста
	//
	// Возвращает:
	//   - int: общее количество комментариев (включая ответы)
	//   - error: ошибка подсчета
	GetCommentStats(ctx context.Context, postID uuid.UUID) (int, error)
}

//go:generate mockery --name SubscriptionService --output ./mocks --filename mock_subscription_service.go

// SubscriptionService определяет интерфейс сервиса для управления real-time подписками.
//
// Этот интерфейс обеспечивает pub/sub функциональность для WebSocket соединений,
// позволяя клиентам подписываться на события комментариев в режиме реального времени.
// Сервис управляет жизненным циклом подписок и доставкой сообщений.
//
// Реализация должна:
// - Безопасно управлять конкурентными подписками
// - Автоматически очищать неактивные соединения
// - Фильтровать события по подпискам
// - Обеспечивать надежную доставку сообщений
// - Предоставлять метрики и мониторинг
//
// Пример использования:
//   subscriptionService := subscription.NewService(logger)
//   events, err := subscriptionService.Subscribe(ctx, postID)
//   for event := range events {
//       // Обработка события комментария
//   }
type SubscriptionService interface {
	// Subscribe создает новую подписку на события комментариев для указанного поста.
	//
	// Метод создает канал для получения событий и регистрирует подписчика
	// в системе уведомлений. Канал автоматически закрывается при отмене контекста
	// или завершении подписки.
	//
	// Параметры:
	//   - ctx: контекст подписки, отмена приводит к закрытию канала
	//   - postID: уникальный идентификатор поста для подписки
	//
	// Возвращает:
	//   - <-chan *model.CommentSubscriptionPayload: канал для получения событий
	//   - error: ошибка создания подписки
	//
	// Жизненный цикл:
	//   - Подписка активна до отмены контекста
	//   - Канал закрывается автоматически при завершении
	//   - Ресурсы освобождаются автоматически
	//
	// Пример использования:
	//   ctx, cancel := context.WithCancel(context.Background())
	//   defer cancel()
	//
	//   events, err := service.Subscribe(ctx, postID)
	//   if err != nil {
	//       return err
	//   }
	//
	//   for event := range events {
	//       switch event.ActionType {
	//       case "CREATED":
	//           fmt.Printf("Новый комментарий: %s\n", event.Comment.Content)
	//       case "UPDATED":
	//           fmt.Printf("Обновлен комментарий: %s\n", event.Comment.Content)
	//       case "DELETED":
	//           fmt.Printf("Удален комментарий: %s\n", event.Comment.ID)
	//       }
	//   }
	Subscribe(ctx context.Context, postID uuid.UUID) (<-chan *model.CommentSubscriptionPayload, error)

	// Publish отправляет событие всем подписчикам указанного поста.
	//
	// Метод рассылает уведомление о событии комментария всем активным
	// подписчикам. Неактивные подписки автоматически удаляются.
	// Доставка происходит асинхронно и не блокирует вызывающий код.
	//
	// Параметры:
	//   - postID: идентификатор поста, подписчикам которого отправляется событие
	//   - payload: данные события для отправки
	//
	// Поведение:
	//   - Отправка происходит асинхронно
	//   - Заблокированные подписчики пропускаются
	//   - Неактивные подписки автоматически удаляются
	//   - Метод не блокируется и всегда завершается быстро
	//
	// Пример использования:
	//   payload := &model.CommentSubscriptionPayload{
	//       PostID: postID,
	//       Comment: newComment,
	//       ActionType: "CREATED",
	//   }
	//   service.Publish(postID, payload)
	Publish(postID uuid.UUID, payload *model.CommentSubscriptionPayload)

	// GetSubscriberCount возвращает количество активных подписчиков для поста.
	//
	// Метод подсчитывает количество активных WebSocket соединений,
	// подписанных на события комментариев для указанного поста.
	// Полезно для мониторинга и отладки.
	//
	// Параметры:
	//   - postID: уникальный идентификатор поста
	//
	// Возвращает:
	//   - int: количество активных подписчиков
	//
	// Пример использования:
	//   count := service.GetSubscriberCount(postID)
	//   if count > 0 {
	//       fmt.Printf("У поста %s есть %d активных подписчиков\n", postID, count)
	//   }
	GetSubscriberCount(postID uuid.UUID) int

	// Shutdown корректно завершает работу сервиса подписок.
	//
	// Метод закрывает все активные подписки, уведомляет подписчиков
	// о завершении работы и освобождает ресурсы. Должен вызываться
	// при остановке приложения.
	//
	// Поведение:
	//   - Закрывает все активные каналы подписок
	//   - Освобождает внутренние ресурсы
	//   - Завершает фоновые горутины
	//   - Блокируется до полного завершения очистки
	//
	// Пример использования:
	//   // При остановке приложения
	//   service.Shutdown()
	Shutdown()
}

// Services объединяет все сервисы приложения в единую структуру.
//
// Эта структура используется для передачи всех сервисов в слои представления
// (GraphQL резолверы) и обеспечивает единую точку доступа к бизнес-логике.
// Упрощает dependency injection и управление зависимостями.
//
// Пример использования:
//   services := &Services{
//       Post: postService,
//       Comment: commentService,
//       Subscription: subscriptionService,
//   }
//   resolver := graphql.NewResolver(services, logger)
type Services struct {
	// Post - сервис для работы с постами
	Post PostService

	// Comment - сервис для работы с комментариями
	Comment CommentService

	// Subscription - сервис для управления real-time подписками
	Subscription SubscriptionService
}
