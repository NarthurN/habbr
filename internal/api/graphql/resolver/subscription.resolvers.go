package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/NarthurN/habbr/internal/api/graphql/converter"
	"github.com/NarthurN/habbr/internal/api/graphql/generated"
	"go.uber.org/zap"
)

// CommentEvents is the resolver for the commentEvents field.
func (r *subscriptionResolver) CommentEvents(ctx context.Context, postID string) (<-chan *generated.CommentEvent, error) {
	r.logger.Debug("CommentEvents subscription", zap.String("postID", postID))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID for subscription", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Подписываемся на события комментариев через сервис подписок
	domainCh, err := r.services.Subscription.Subscribe(ctx, parsedPostID)
	if err != nil {
		r.logger.Error("Failed to subscribe to comment events", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Создаем канал для GraphQL событий
	eventCh := make(chan *generated.CommentEvent, 10)

	// Горутина для конвертации domain событий в GraphQL события
	go func() {
		defer close(eventCh)
		defer r.logger.Debug("CommentEvents subscription closed", zap.String("postID", postID))

		for {
			select {
			case <-ctx.Done():
				r.logger.Debug("CommentEvents subscription cancelled", zap.String("postID", postID))
				return
			case payload, ok := <-domainCh:
				if !ok {
					r.logger.Debug("Domain channel closed", zap.String("postID", postID))
					return
				}

				// Конвертируем в GraphQL событие
				gqlEvent, err := converter.CommentEventToGraphQL(payload.ActionType, payload.Comment)
				if err != nil {
					r.logger.Error("Failed to convert comment event", zap.Error(err))
					continue
				}

				select {
				case eventCh <- gqlEvent:
					r.logger.Debug("Comment event sent",
						zap.String("postID", postID),
						zap.String("type", payload.ActionType),
						zap.String("commentID", payload.Comment.ID.String()))
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	r.logger.Info("CommentEvents subscription established", zap.String("postID", postID))
	return eventCh, nil
}

// AllCommentEvents is the resolver for the allCommentEvents field.
func (r *subscriptionResolver) AllCommentEvents(ctx context.Context) (<-chan *generated.CommentEvent, error) {
	r.logger.Debug("AllCommentEvents subscription")

	// TODO: Реализовать подписку на все события комментариев
	// Пока возвращаем заглушку
	eventCh := make(chan *generated.CommentEvent)

	go func() {
		defer close(eventCh)
		<-ctx.Done()
		r.logger.Debug("AllCommentEvents subscription cancelled")
	}()

	return eventCh, nil
}

// NewPosts is the resolver for the newPosts field.
func (r *subscriptionResolver) NewPosts(ctx context.Context) (<-chan *generated.Post, error) {
	r.logger.Debug("NewPosts subscription")

	// TODO: Реализовать подписку на новые посты
	// Пока возвращаем заглушку
	postCh := make(chan *generated.Post)

	go func() {
		defer close(postCh)
		<-ctx.Done()
		r.logger.Debug("NewPosts subscription cancelled")
	}()

	return postCh, nil
}

// PostUpdates is the resolver for the postUpdates field.
func (r *subscriptionResolver) PostUpdates(ctx context.Context, postID string) (<-chan *generated.Post, error) {
	r.logger.Debug("PostUpdates subscription", zap.String("postID", postID))

	// Парсим ID поста
	_, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID for subscription", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// TODO: Реализовать подписку на обновления поста
	// Пока возвращаем заглушку
	postCh := make(chan *generated.Post)

	go func() {
		defer close(postCh)
		<-ctx.Done()
		r.logger.Debug("PostUpdates subscription cancelled", zap.String("postID", postID))
	}()

	return postCh, nil
}

// PostStatsUpdates is the resolver for the postStatsUpdates field.
func (r *subscriptionResolver) PostStatsUpdates(ctx context.Context, postID string) (<-chan *generated.PostStats, error) {
	r.logger.Debug("PostStatsUpdates subscription", zap.String("postID", postID))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID for subscription", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Подписываемся на события комментариев для получения статистики
	domainCh, err := r.services.Subscription.Subscribe(ctx, parsedPostID)
	if err != nil {
		r.logger.Error("Failed to subscribe to comment events for stats", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Создаем канал для статистики
	statsCh := make(chan *generated.PostStats, 10)

	// Горутина для обновления статистики при изменении комментариев
	go func() {
		defer close(statsCh)
		defer r.logger.Debug("PostStatsUpdates subscription closed", zap.String("postID", postID))

		// Отправляем текущую статистику
		if stats, err := getCurrentPostStats(ctx, r.services, parsedPostID); err == nil {
			select {
			case statsCh <- stats:
			case <-ctx.Done():
				return
			}
		}

		// Слушаем события комментариев и обновляем статистику
		for {
			select {
			case <-ctx.Done():
				r.logger.Debug("PostStatsUpdates subscription cancelled", zap.String("postID", postID))
				return
			case _, ok := <-domainCh:
				if !ok {
					return
				}

				// Получаем обновленную статистику
				stats, err := getCurrentPostStats(ctx, r.services, parsedPostID)
				if err != nil {
					r.logger.Error("Failed to get updated post stats", zap.String("postID", postID), zap.Error(err))
					continue
				}

				select {
				case statsCh <- stats:
					r.logger.Debug("Post stats updated", zap.String("postID", postID))
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	r.logger.Info("PostStatsUpdates subscription established", zap.String("postID", postID))
	return statsCh, nil
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
