package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"time"

	"github.com/NarthurN/habbr/internal/api/graphql/converter"
	"github.com/NarthurN/habbr/internal/api/graphql/generated"
	"go.uber.org/zap"
)

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, first *int, after *string, last *int, before *string, filter *generated.PostFilter) (*generated.PostConnection, error) {
	r.logger.Debug("Posts query", zap.Any("filter", filter))

	// Конвертируем фильтр
	domainFilter, err := converter.PostFilterFromGraphQL(filter)
	if err != nil {
		r.logger.Error("Failed to convert post filter", zap.Error(err))
		return nil, err
	}

	// Конвертируем пагинацию
	pagination := converter.PaginationFromGraphQL(first, last, after, before)

	// Получаем посты через сервис
	connection, err := r.services.Post.ListPosts(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to get posts", zap.Error(err))
		return nil, err
	}

	return converter.PostConnectionToGraphQL(connection), nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*generated.Post, error) {
	r.logger.Debug("Post query", zap.String("id", id))

	// Парсим ID
	postID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	// Получаем пост через сервис
	post, err := r.services.Post.GetPost(ctx, postID)
	if err != nil {
		r.logger.Error("Failed to get post", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	return converter.PostToGraphQL(post), nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID string, first *int, after *string, last *int, before *string, filter *generated.CommentFilter) (*generated.CommentConnection, error) {
	r.logger.Debug("Comments query", zap.String("postID", postID))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Конвертируем фильтр
	domainFilter, err := converter.CommentFilterFromGraphQL(filter)
	if err != nil {
		r.logger.Error("Failed to convert comment filter", zap.Error(err))
		return nil, err
	}

	// Устанавливаем PostID в фильтре
	domainFilter.PostID = &parsedPostID

	// Конвертируем пагинацию
	pagination := converter.PaginationFromGraphQL(first, last, after, before)

	// Получаем комментарии через сервис
	connection, err := r.services.Comment.ListComments(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to get comments", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	return converter.CommentConnectionToGraphQL(connection), nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*generated.Comment, error) {
	r.logger.Debug("Comment query", zap.String("id", id))

	// Парсим ID
	commentID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid comment ID", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	// Получаем комментарий через сервис
	comment, err := r.services.Comment.GetComment(ctx, commentID)
	if err != nil {
		r.logger.Error("Failed to get comment", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	return converter.CommentToGraphQL(comment), nil
}

// CommentTree is the resolver for the commentTree field.
func (r *queryResolver) CommentTree(ctx context.Context, postID string, maxDepth *int, filter *generated.CommentFilter) ([]*generated.Comment, error) {
	r.logger.Debug("CommentTree query", zap.String("postID", postID), zap.Any("maxDepth", maxDepth))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Получаем дерево комментариев через сервис
	tree, err := r.services.Comment.GetCommentsTree(ctx, parsedPostID)
	if err != nil {
		r.logger.Error("Failed to get comment tree", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Конвертируем в GraphQL формат
	result := make([]*generated.Comment, len(tree))
	for i, comment := range tree {
		result[i] = converter.CommentToGraphQL(comment)
	}

	return result, nil
}

// PostStats is the resolver for the postStats field.
func (r *queryResolver) PostStats(ctx context.Context, id string) (*generated.PostStats, error) {
	r.logger.Debug("PostStats query", zap.String("id", id))

	// Парсим ID
	postID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	// Получаем пост для проверки существования
	post, err := r.services.Post.GetPost(ctx, postID)
	if err != nil {
		r.logger.Error("Failed to get post for stats", zap.String("id", id), zap.Error(err))
		return nil, err
	}

	// Получаем количество комментариев
	filter := generated.CommentFilter{}
	domainFilter, _ := converter.CommentFilterFromGraphQL(&filter)
	domainFilter.PostID = &postID

	pagination := converter.PaginationFromGraphQL(nil, nil, nil, nil)
	comments, err := r.services.Comment.ListComments(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to get comments for stats", zap.String("postID", id), zap.Error(err))
		return nil, err
	}

	// Находим последний комментарий
	var lastCommentAt *time.Time
	if len(comments.Edges) > 0 {
		// Сортируем по дате создания и берем последний
		for _, edge := range comments.Edges {
			if lastCommentAt == nil || edge.Node.CreatedAt.After(*lastCommentAt) {
				lastCommentAt = &edge.Node.CreatedAt
			}
		}
	}

	return &generated.PostStats{
		TotalComments:   len(comments.Edges),
		CommentsEnabled: post.CommentsEnabled,
		LastCommentAt:   lastCommentAt,
	}, nil
}

// CommentStats is the resolver for the commentStats field.
func (r *queryResolver) CommentStats(ctx context.Context, postID string) (*generated.CommentStats, error) {
	r.logger.Debug("CommentStats query", zap.String("postID", postID))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Получаем все комментарии поста
	filter := generated.CommentFilter{}
	domainFilter, _ := converter.CommentFilterFromGraphQL(&filter)
	domainFilter.PostID = &parsedPostID

	pagination := converter.PaginationFromGraphQL(nil, nil, nil, nil)
	comments, err := r.services.Comment.ListComments(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to get comments for stats", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	totalComments := len(comments.Edges)
	maxDepth := 0
	totalDepth := 0

	// Вычисляем статистику глубины
	for _, edge := range comments.Edges {
		depth := edge.Node.Depth
		if depth > maxDepth {
			maxDepth = depth
		}
		totalDepth += depth
	}

	var averageDepth float64 = 0
	if totalComments > 0 {
		averageDepth = float64(totalDepth) / float64(totalComments)
	}

	return &generated.CommentStats{
		TotalComments: totalComments,
		MaxDepth:      maxDepth,
		AverageDepth:  averageDepth,
	}, nil
}

// SearchPosts is the resolver for the searchPosts field.
func (r *queryResolver) SearchPosts(ctx context.Context, query string, first *int, after *string) (*generated.PostConnection, error) {
	r.logger.Debug("SearchPosts query", zap.String("query", query))

	// Создаем фильтр для поиска
	filter := generated.PostFilter{
		Title:   &query,
		Content: &query,
	}
	domainFilter, err := converter.PostFilterFromGraphQL(&filter)
	if err != nil {
		r.logger.Error("Failed to convert search filter", zap.Error(err))
		return nil, err
	}

	// Конвертируем пагинацию
	pagination := converter.PaginationFromGraphQL(first, nil, after, nil)

	// Выполняем поиск через сервис
	connection, err := r.services.Post.ListPosts(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to search posts", zap.String("query", query), zap.Error(err))
		return nil, err
	}

	return converter.PostConnectionToGraphQL(connection), nil
}

// SearchComments is the resolver for the searchComments field.
func (r *queryResolver) SearchComments(ctx context.Context, postID string, query string, first *int, after *string) (*generated.CommentConnection, error) {
	r.logger.Debug("SearchComments query", zap.String("postID", postID), zap.String("query", query))

	// Парсим ID поста
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return nil, err
	}

	// Создаем фильтр для поиска (здесь можно расширить логику поиска)
	filter := generated.CommentFilter{}
	domainFilter, err := converter.CommentFilterFromGraphQL(&filter)
	if err != nil {
		r.logger.Error("Failed to convert search filter", zap.Error(err))
		return nil, err
	}

	domainFilter.PostID = &parsedPostID

	// Конвертируем пагинацию
	pagination := converter.PaginationFromGraphQL(first, nil, after, nil)

	// Выполняем поиск через сервис
	connection, err := r.services.Comment.ListComments(ctx, *domainFilter, *pagination)
	if err != nil {
		r.logger.Error("Failed to search comments", zap.String("postID", postID), zap.String("query", query), zap.Error(err))
		return nil, err
	}

	return converter.CommentConnectionToGraphQL(connection), nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
