package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/NarthurN/habbr/internal/api/graphql/converter"
	"github.com/NarthurN/habbr/internal/api/graphql/generated"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input generated.PostInput) (*generated.PostResult, error) {
	r.logger.Debug("CreatePost mutation", zap.String("title", input.Title))

	// Конвертируем входные данные
	domainInput, err := converter.PostInputFromGraphQL(input)
	if err != nil {
		r.logger.Error("Failed to convert post input", zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	// Создаем пост через сервис
	post, err := r.services.Post.CreatePost(ctx, *domainInput)
	if err != nil {
		r.logger.Error("Failed to create post", zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Post created successfully", zap.String("id", post.ID.String()))
	return converter.PostResultToGraphQL(post, nil), nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, input generated.PostUpdateInput) (*generated.PostResult, error) {
	r.logger.Debug("UpdatePost mutation", zap.String("id", id))

	// Парсим ID
	postID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("id", id), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	// Конвертируем входные данные
	domainInput, err := converter.PostUpdateInputFromGraphQL(input)
	if err != nil {
		r.logger.Error("Failed to convert post update input", zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Обновляем пост через сервис
	post, err := r.services.Post.UpdatePost(ctx, postID, *domainInput, authorID)
	if err != nil {
		r.logger.Error("Failed to update post", zap.String("id", id), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Post updated successfully", zap.String("id", post.ID.String()))
	return converter.PostResultToGraphQL(post, nil), nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (*generated.DeleteResult, error) {
	r.logger.Debug("DeletePost mutation", zap.String("id", id))

	// Парсим ID
	postID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("id", id), zap.Error(err))
		return converter.DeleteResultToGraphQL(uuid.Nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Удаляем пост через сервис
	err = r.services.Post.DeletePost(ctx, postID, authorID)
	if err != nil {
		r.logger.Error("Failed to delete post", zap.String("id", id), zap.Error(err))
		return converter.DeleteResultToGraphQL(uuid.Nil, err), nil
	}

	r.logger.Info("Post deleted successfully", zap.String("id", id))
	return converter.DeleteResultToGraphQL(postID, nil), nil
}

// EnableComments is the resolver for the enableComments field.
func (r *mutationResolver) EnableComments(ctx context.Context, postID string) (*generated.PostResult, error) {
	r.logger.Debug("EnableComments mutation", zap.String("postID", postID))

	// Парсим ID
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Включаем комментарии через сервис
	post, err := r.services.Post.ToggleComments(ctx, parsedPostID, authorID, true)
	if err != nil {
		r.logger.Error("Failed to enable comments", zap.String("postID", postID), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Comments enabled for post", zap.String("postID", postID))
	return converter.PostResultToGraphQL(post, nil), nil
}

// DisableComments is the resolver for the disableComments field.
func (r *mutationResolver) DisableComments(ctx context.Context, postID string) (*generated.PostResult, error) {
	r.logger.Debug("DisableComments mutation", zap.String("postID", postID))

	// Парсим ID
	parsedPostID, err := converter.ParseID(postID)
	if err != nil {
		r.logger.Error("Invalid post ID", zap.String("postID", postID), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Отключаем комментарии через сервис
	post, err := r.services.Post.ToggleComments(ctx, parsedPostID, authorID, false)
	if err != nil {
		r.logger.Error("Failed to disable comments", zap.String("postID", postID), zap.Error(err))
		return converter.PostResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Comments disabled for post", zap.String("postID", postID))
	return converter.PostResultToGraphQL(post, nil), nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input generated.CommentInput) (*generated.CommentResult, error) {
	r.logger.Debug("CreateComment mutation", zap.String("postID", input.PostID))

	// Конвертируем входные данные
	domainInput, err := converter.CommentInputFromGraphQL(input)
	if err != nil {
		r.logger.Error("Failed to convert comment input", zap.Error(err))
		return converter.CommentResultToGraphQL(nil, err), nil
	}

	// Создаем комментарий через сервис
	comment, err := r.services.Comment.CreateComment(ctx, *domainInput)
	if err != nil {
		r.logger.Error("Failed to create comment", zap.Error(err))
		return converter.CommentResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Comment created successfully", zap.String("id", comment.ID.String()))
	return converter.CommentResultToGraphQL(comment, nil), nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, input generated.CommentUpdateInput) (*generated.CommentResult, error) {
	r.logger.Debug("UpdateComment mutation", zap.String("id", id))

	// Парсим ID
	commentID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid comment ID", zap.String("id", id), zap.Error(err))
		return converter.CommentResultToGraphQL(nil, err), nil
	}

	// Конвертируем входные данные
	domainInput, err := converter.CommentUpdateInputFromGraphQL(input)
	if err != nil {
		r.logger.Error("Failed to convert comment update input", zap.Error(err))
		return converter.CommentResultToGraphQL(nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Обновляем комментарий через сервис
	comment, err := r.services.Comment.UpdateComment(ctx, commentID, *domainInput, authorID)
	if err != nil {
		r.logger.Error("Failed to update comment", zap.String("id", id), zap.Error(err))
		return converter.CommentResultToGraphQL(nil, err), nil
	}

	r.logger.Info("Comment updated successfully", zap.String("id", comment.ID.String()))
	return converter.CommentResultToGraphQL(comment, nil), nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (*generated.DeleteResult, error) {
	r.logger.Debug("DeleteComment mutation", zap.String("id", id))

	// Парсим ID
	commentID, err := converter.ParseID(id)
	if err != nil {
		r.logger.Error("Invalid comment ID", zap.String("id", id), zap.Error(err))
		return converter.DeleteResultToGraphQL(uuid.Nil, err), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Удаляем комментарий через сервис
	err = r.services.Comment.DeleteComment(ctx, commentID, authorID)
	if err != nil {
		r.logger.Error("Failed to delete comment", zap.String("id", id), zap.Error(err))
		return converter.DeleteResultToGraphQL(uuid.Nil, err), nil
	}

	r.logger.Info("Comment deleted successfully", zap.String("id", id))
	return converter.DeleteResultToGraphQL(commentID, nil), nil
}

// DeleteCommentsBatch is the resolver for the deleteCommentsBatch field.
func (r *mutationResolver) DeleteCommentsBatch(ctx context.Context, postID string, commentIDs []string) (*generated.BatchDeleteResult, error) {
	r.logger.Debug("DeleteCommentsBatch mutation", zap.String("postID", postID), zap.Int("count", len(commentIDs)))

	var deletedIDs []uuid.UUID
	var errors []error

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Удаляем комментарии по одному
	for _, idStr := range commentIDs {
		commentID, err := converter.ParseID(idStr)
		if err != nil {
			r.logger.Error("Invalid comment ID in batch", zap.String("id", idStr), zap.Error(err))
			errors = append(errors, err)
			continue
		}

		err = r.services.Comment.DeleteComment(ctx, commentID, authorID)
		if err != nil {
			r.logger.Error("Failed to delete comment in batch", zap.String("id", idStr), zap.Error(err))
			errors = append(errors, err)
		} else {
			deletedIDs = append(deletedIDs, commentID)
		}
	}

	r.logger.Info("Batch comment deletion completed",
		zap.Int("deleted", len(deletedIDs)),
		zap.Int("errors", len(errors)))

	return converter.BatchDeleteResultToGraphQL(deletedIDs, errors), nil
}

// DeleteCommentsTree is the resolver for the deleteCommentsTree field.
func (r *mutationResolver) DeleteCommentsTree(ctx context.Context, commentID string) (*generated.BatchDeleteResult, error) {
	r.logger.Debug("DeleteCommentsTree mutation", zap.String("commentID", commentID))

	// Парсим ID
	parsedCommentID, err := converter.ParseID(commentID)
	if err != nil {
		r.logger.Error("Invalid comment ID", zap.String("commentID", commentID), zap.Error(err))
		return converter.BatchDeleteResultToGraphQL(nil, []error{err}), nil
	}

	// TODO: Получить AuthorID из контекста аутентификации
	// Пока используем фиктивный ID
	authorID := uuid.New()

	// Для удаления дерева комментариев нужно сначала получить все дочерние комментарии
	// Пока просто удаляем один комментарий
	err = r.services.Comment.DeleteComment(ctx, parsedCommentID, authorID)
	if err != nil {
		r.logger.Error("Failed to delete comment tree", zap.String("commentID", commentID), zap.Error(err))
		return converter.BatchDeleteResultToGraphQL(nil, []error{err}), nil
	}

	r.logger.Info("Comment tree deleted successfully", zap.String("commentID", commentID))
	return converter.BatchDeleteResultToGraphQL([]uuid.UUID{parsedCommentID}, nil), nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
